Shader "Custom/ToonWater"
{
	Properties
	{
		// What color the water will sample when the surface below is shallow.
		_DepthGradientShallow("Depth Gradient Shallow", Color) = (0.325, 0.807, 0.971, 0.725)

		// What color the water will sample when the surface below is at its deepest.
		_DepthGradientDeep("Depth Gradient Deep", Color) = (0.086, 0.407, 1, 0.749)

		// Maximum distance the surface below the water will affect the color gradient.
		_DepthMaxDistance("Depth Maximum Distance", Float) = 1

		// Color to render the foam generated by objects intersecting the surface.
		_FoamColor("Foam Colour", Color) = (1,1,1,1)
		_FoamColor2("Foam Secondary Colour", Color) = (1,1,1,1)

		// Noise texture used to generate waves.
		_SurfaceNoise("Surface Noise", 2D) = "white" {}

	// Speed, in UVs per second the noise will scroll. Only the xy components are used.
	_SurfaceNoiseScroll("Surface Noise Scroll Amount", Vector) = (0.03, 0.03, 0, 0)

		// Values in the noise texture above this cutoff are rendered on the surface.
		_SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.777

		// Red and green channels of this texture are used to offset the
		// noise texture to create distortion in the waves.
		_SurfaceDistortion("Surface Distortion", 2D) = "white" {}

	// Multiplies the distortion by this value.
		_SurfaceDistortionAmount("Surface Distortion Amount", Range(0, 1)) = 0.27

		_WaveAmp("Wave Amplitude", Range(0, 1)) = 0.27
		_WaveFreq("Wave Frequency", Range(0, 100)) = 0.27
		_Direction("Direction", Vector) = (1.0,0.0,0.0,1.0)

		// Control the distance that surfaces below the water will contribute
		// to foam being rendered.
		_FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
		_FoamMinDistance("Foam Minimum Distance", Float) = 0.04


		_ReflectionTex("Reflection Texture", 2D) = "black" {}
		_ReflectionStrength("Reflection Strength", Range(0, 1)) = 0.5

		_RippleTex("Ripple Texture", 2D) = "black" {}
		_RippleSpeed("Ripple Speed", Float) = 0.5
		_RippleScale("Ripple Scale", Float) = 0.1
		_RippleOrigin("Ripple Origin", Vector) = (0,0,0,0)
		_RippleStartTime("Ripple Start Time", Float) = 0.0


		
	}
		SubShader
	{
		Tags
		{
			"Queue" = "Transparent"
			"RenderType" = "Transparent"
		}

		Pass
		{
			// Transparent "normal" blending.
			Blend SrcAlpha OneMinusSrcAlpha
			ZWrite Off

			CGPROGRAM
			#define SMOOTHSTEP_AA 0.01

			#pragma vertex vert
			#pragma fragment frag
			#pragma multi_compile_fog
			#include "UnityCG.cginc"

		// Blends two colors using the same algorithm that our shader is using
		// to blend with the screen. This is usually called "normal blending",
		// and is similar to how software like Photoshop blends two layers.
		float4 alphaBlend(float4 top, float4 bottom)
		{
			float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
			float alpha = top.a + bottom.a * (1 - top.a);

			return float4(color, alpha);
		}

		struct appdata
		{
			float4 vertex : POSITION;
			float4 uv : TEXCOORD0;
			float3 normal : NORMAL;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float2 noiseUV : TEXCOORD0;

			

			float2 distortUV : TEXCOORD1;
			float4 screenPosition : TEXCOORD2;
			float3 viewNormal : NORMAL;
			float4 worldPos : TEXCOORD3;

			UNITY_FOG_COORDS(4) //Using TEXCOORD4 as it is available.
		};

		sampler2D _RippleTex;
		float4 _RippleOrigin; //xyz position.
		float _RippleStartTime;
		float _RippleSpeed;
		float _RippleScale;

		sampler2D _ReflectionTex;
		float4x4 _MainCameraVP;
		float _ReflectionStrength;

		sampler2D _SurfaceNoise;
		float4 _SurfaceNoise_ST;

		sampler2D _SurfaceDistortion;
		float4 _SurfaceDistortion_ST;

		float4 _Direction;
		float _WaveFreq;
		float _WaveAmp;

		v2f vert(appdata v)
		{
			float3 pos = v.vertex.xyz;
			float4 dir = normalize(_Direction); // Your wave direction (should be in world or object space)

			float defaultWavelength = 2 * UNITY_PI;
			float wL = defaultWavelength / _WaveFreq;

			// Phase: wave propagation speed
			float phase = sqrt(9.8 / wL);

			// Position in wave cycle (dot gives directional displacement)
			float disp = wL * (dot(dir.xyz, pos) - (phase * _Time.y));

			// Apply sine wave displacement along Y axis
			pos.y += _WaveAmp * sin(disp);

			v.vertex.xyz = pos;

			float3 displacedPos = pos;
			float4 worldPos = mul(unity_ObjectToWorld, float4(displacedPos, 1.0));


			v2f o;

			o.worldPos = worldPos;

			o.vertex = UnityObjectToClipPos(v.vertex);
			o.screenPosition = ComputeScreenPos(o.vertex);
			o.distortUV = TRANSFORM_TEX(v.uv, _SurfaceDistortion);
			o.noiseUV = TRANSFORM_TEX(v.uv, _SurfaceNoise);
			o.viewNormal = COMPUTE_VIEW_NORMAL;

			UNITY_TRANSFER_FOG(o, o.vertex);

			return o;
		}

		float4 _DepthGradientShallow;
		float4 _DepthGradientDeep;
		float4 _FoamColor;
		float4 _FoamColor2;

		float _DepthMaxDistance;
		float _FoamMaxDistance;
		float _FoamMinDistance;
		float _SurfaceNoiseCutoff;
		float _SurfaceDistortionAmount;

		float2 _SurfaceNoiseScroll;

		sampler2D _CameraDepthTexture;
		sampler2D _CameraNormalsTexture;

		// 2D Voronoi function returning cell distance (simplified)
		float voronoi(in float2 x)
		{
			float2 n = floor(x);
			float2 f = frac(x);

			float md = 1.0; // minimum distance
			for (int j = -1; j <= 1; j++)
			{
				for (int i = -1; i <= 1; i++)
				{
					float2 g = float2(i, j);
					float2 o = frac(sin(dot(n + g, float2(12.9898, 78.233))) * 43758.5453);
					float2 r = g + o - f;
					float d = dot(r, r);
					if (d < md)
						md = d;
				}
			}
			return md;
		}


		float4 frag(v2f i) : SV_Target
		{

			float rippleAge = _Time.y - _RippleStartTime;

			if (rippleAge > 1) {
				//return float4(1,0,0, 1);
			}

			float2 worldXZ = i.worldPos.xz;
			//float2 ripplePos = _RippleOrigin.xz;

			float2 ripplePos = float2(0, 0);

			float dist = distance(worldXZ, ripplePos);


			// Try different scales — this will help you see *something*
			//return float4(saturate(dist / 10.0), 0, 0, 1); // Red = near 0, Black = far

			float rippleRadius = rippleAge * _RippleSpeed;


		
			//return float4(dist.xxx, 1); // scale to visualize

			// Soft falloff
			float rippleBandWidth = 0.5; // Thickness of the ripple
			float falloff = smoothstep(rippleRadius - rippleBandWidth, rippleRadius, dist)
				* (1.0 - smoothstep(rippleRadius, rippleRadius + rippleBandWidth, dist));

			return float4(falloff,0,0, 1); // Grayscale visual

			// UV to sample ripple texture
			float2 rippleUV = (worldXZ - ripplePos) / (_RippleScale * rippleRadius) + 0.5;
			float ripple = tex2D(_RippleTex, rippleUV).r * falloff;

			float rippleStrength = 1; // Adjust to control how strong the ripple shows
			//float4 rippleColour = float4(ripple * float3(0, 1, 0), ripple * rippleStrength);

			float4 rippleColour = float4(1, 0, 0, 1);


			// Retrieve the current depth value of the surface behind the
			// pixel we are currently rendering.
			float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition)).r;
		// Convert the depth from non-linear 0...1 range to linear
		// depth, in Unity units.
		float existingDepthLinear = LinearEyeDepth(existingDepth01);

		// Difference, in Unity units, between the water's surface and the object behind it.
		float depthDifference = existingDepthLinear - i.screenPosition.w;

		// Calculate the color of the water based on the depth using our two gradient colors.
		float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
		float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);

		// Retrieve the view-space normal of the surface behind the
		// pixel we are currently rendering.
		float3 existingNormal = tex2Dproj(_CameraNormalsTexture, UNITY_PROJ_COORD(i.screenPosition));

		// Modulate the amount of foam we display based on the difference
		// between the normals of our water surface and the object behind it.
		// Larger differences allow for extra foam to attempt to keep the overall
		// amount consistent.
		float3 normalDot = saturate(dot(existingNormal, i.viewNormal));
		float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
		float foamDepthDifference01 = saturate(depthDifference / foamDistance);

		float sineTime = (sin(_Time.y * 0.8) * 0.5 + 0.5); // Remaps to 0 -> 1
		sineTime *= 0.7;
		sineTime += 0.3;
		float surfaceNoise2 = sineTime * foamDepthDifference01 * _SurfaceNoiseCutoff;

		float surfaceNoiseCutoff = step(0.1, surfaceNoise2);



		float2 distortSample = (tex2D(_SurfaceDistortion, i.distortUV).xy * 2 - 1) * _SurfaceDistortionAmount;

		// Distort the noise UV based off the RG channels (using xy here) of the distortion texture.
		// Also offset it by time, scaled by the scroll speed.
		float2 noiseUV = float2((i.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x) + distortSample.x,
		(i.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y) + distortSample.y);
		float surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;

		// Use smoothstep to ensure we get some anti-aliasing in the transition from foam to surface.
		// Uncomment the line below to see how it looks without AA.
		 float surfaceNoise = surfaceNoiseSample > surfaceNoiseCutoff ? 1 : 0;
		//float surfaceNoise = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);

		float4 surfaceNoiseColor = _FoamColor;
		float4 surfaceNoiseColor2 = _FoamColor2;
		surfaceNoiseColor.a *= step(0.5,surfaceNoise);
		surfaceNoiseColor2.a *= step(0.7, surfaceNoise);

		// Use normal alpha blending to combine the foam with the surface.
		//return alphaBlend(surfaceNoiseColor, waterColor);

		// Get screen UV
		float2 screenUV = i.screenPosition.xy / i.screenPosition.w;
		screenUV.y = 1 - screenUV.y; // Flip Y for Unity

		// Sample reflection
		//float4 reflectionCol = tex2Dproj(_ReflectionTex, UNITY_PROJ_COORD(i.screenPosition));
		float4 projPos = mul(_MainCameraVP, i.worldPos);
		float4 screenUV2 = ComputeScreenPos(projPos);
		float4 reflectionCol = tex2Dproj(_ReflectionTex, UNITY_PROJ_COORD(screenUV2));

		// Mix with water surface color
		float4 waterWithReflection = lerp(waterColor, reflectionCol, _ReflectionStrength);
		float4 finalColor = alphaBlend(surfaceNoiseColor, waterWithReflection);

		float voronoiScale = 100.0;
		float v = voronoi(i.noiseUV * voronoiScale * 0.10);

		v = step(surfaceNoiseSample, v);

		float edge = smoothstep(0.1, 0.6, v);
		float4 voronoiColor = float4(edge, edge, edge, 1);

		float4 waterWithVoronoi = waterWithReflection * (0.7 + 0.3 * voronoiColor);


		float voronoiScale2 = 90.0;
		float v2 = voronoi(i.noiseUV * voronoiScale2 * 0.15);

		v2 = step(surfaceNoiseSample, v2);

		float edge2 = smoothstep(0.4, 0.5, v2);
		float4 voronoiColor2 = float4(edge2, edge2, edge2, 1);

		float4 waterWithVoronoi2 = waterWithVoronoi * (0.7 + 0.3 * voronoiColor2);

		finalColor = alphaBlend(surfaceNoiseColor, waterWithVoronoi2);

		float4 colourPass1 = alphaBlend(surfaceNoiseColor2, finalColor);

		UNITY_APPLY_FOG(i.fogCoord, finalColor);

		//return rippleColour;

		float4 finalColorWRipple = alphaBlend(rippleColour, finalColor);

		//finalColor.Albedo += ripple * float3(0, 1, 0);

		return finalColorWRipple;
		return finalColor;


		//return colourPass1;

		

	}
	ENDCG
}
	}
}